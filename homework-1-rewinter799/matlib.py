"""
matlib.py

Put any requested function or class definitions in this file.  You can use these in your script.

Please use comments and docstrings to make the file readable.
"""

from matlib import *
import numpy as np
import scipy as sp
import numpy.linalg as la
import scipy.linalg as sla
import matplotlib.pyplot as plt
from scipy.stats import norm

# Problem 0

# Part A
def eval_simulation(n):
    """
    Creates 100 symmetric n x n matrices whose entries are independent
    standard normal random variables, and returns an ndarray containing
    all 100n eigenvalues of those matrices.

    Argument n is matrix dimension, assumed to be a positive integer.
    """
    # Initialize empty array of eigenvalues
    evals = np.array([])
    for i in range(100):
        A = np.random.randn(n, n)
        # Make randomly-generated matrix A symmetric
        for j in range(n):
            for k in range(j+1, n):
                A[j, k] = A[k, j]
        # Calculate eigenvalues and add to running list
        lambdas = sla.eigh(A, eigvals_only = True)
        evals = np.append(evals, lambdas)
    return evals

def graph_hist_evals(evals):
    """
    Plots a histogram of eigenvalues generated by eval_simulation(n).
    Also overlays the PDF of the Wigner semicircle distribution with
    radius 2n, where n is the dimension of the matrices whose eigenvalues
    are being plotted.

    Argument evals is an ndarray of eigenvalues, to be generated by
    eval_simulation(n).
    """
    # Labels
    plt.xlabel("Eigenvalues")
    plt.ylabel("Frequency")
    plt.title("Histogram of Eigenvalues of n x n Matrices\
              \nwith Entries Distributed N(0,1)")

    # Plot histogram
    plt.hist(evals, density = True, bins = 20)
    
    # Define Wigner semicircle distribution PDF
    def wigner(x, r):
        return (2/(np.pi*r**2)) * np.sqrt(r**2 - x**2)
    
    # Plot Wigner semicircle distribution with radius 2n
    xmin, xmax = plt.xlim()
    x = np.linspace(xmin, xmax, 100)
    plt.plot(x, wigner(x, 2*np.sqrt(len(evals)/100)), linewidth = 3, 
             color = "black")
    
    # Plot errors between empirical data and hypothesized Wigner fit
    hist_values, hist_edges = np.histogram(evals, density = True, bins = 20)
    errors = np.abs(np.array(wigner(hist_edges[0:-1], 
                                    2*np.sqrt(len(evals)/100))) 
                    - hist_values)
    plt.plot(hist_edges[0:-1], errors, linewidth = 3, color = "red")

# Part D
def singular_vals_simulation(n):
    """
    Creates 100 symmetric n x n matrices whose entries are independent
    standard normal random variables, and returns an ndarray containing
    all 100n singular values of those matrices.

    Argument n is matrix dimension, assumed to be a positive integer.

    Output singular_vals is an ndarray of 100n singular values corresponding
    to 100 randomly-generated matrices.
    Output condition_numbers is an ndarray of 100 condition numbers
    corresponding to 100 randomly-generated matrices.
    """
    # Initialize empty array of singular values
    singular_vals = np.array([])
    condition_numbers = np.array([])
    for i in range(100):
        A = np.random.randn(n, n)
        # Make randomly-generated matrix A symmetric
        for j in range(n):
            for k in range(j+1, n):
                A[j, k] = A[k, j]
        # Calculate singular values and add to running list
        U, S, Vt = la.svd(A)
        singular_vals = np.append(singular_vals, S)
        condition_numbers = np.append(condition_numbers, np.max(S)/np.min(S))
    return singular_vals, condition_numbers

def graph_hist_singular_vals(singular_vals):
    """
    Plots a histogram of singular values generated by
    singular_vals_simulation(n).

    Argument singular_vals is an ndarray of singular values, generated by
    singular_vals_simulation(n).
    """
    # Labels
    plt.xlabel("Singular Values")
    plt.ylabel("Frequency")
    plt.title("Histogram of Singular Values of n x n Matrices\
              \nwith Entries Distributed N(0,1)")

    # Plot histogram
    plt.hist(singular_vals, density = True, bins = 20)

# Part E
def graph_hist_condition_numbers(condition_numbers):
    """
    Plots a histogram of condition numbers generated by
    singular_vals_simulation(n).

    Argument condition_numbers is an ndarray of singular values, generated by
    singular_vals_simulation(n).
    """
    # Labels
    plt.xlabel("Condition Numbers")
    plt.ylabel("Frequency")
    
    # Plot histogram
    plt.hist(condition_numbers, density = True, bins = 20)

# Problem 1

#Part A
def solve_chol(A, b):
    """
    Computes a vector x that solves A @ x = b.

    Assumes A is a symmetric positive definite matrix of size n x n.
    Assumes b is a vector of size n.
    """
    # Step 0: Cholesky decomposition, so A @ x = b can be written as
    # L @ L.T @ x = b.
    L = sla.cholesky(A, lower = True)

    # Step 1: Left multiply L @ L.T @ x = b by L^-1,
    # such that c = L^-1 @ b.
    c = sla.solve_triangular(L, b, lower = True)

    # Step 2: Left multiply L.T @ x = c by L.T^-1, 
    # such that x = L.T^-1 @ c = L.T^-1 @ L^-1 @ b.
    x = sla.solve_triangular(L.T, c, lower = False)
    return x

# Part C
def matrix_pow(A, n):
    """
    Computes the matrix power A**n using the Eigenvalue decomposition.

    Argument A is assumed to be a symmetric m x m matrix.
    n >= 0 is assumed to be an integer.
    """
    # Performs the eigendecomposition of A. evals is a vector of eigenvalues;
    # Q is a matrix of eigenvectors.
    evals, Q = sla.eigh(A)

    # Create a diagonal matrix of eigenvalues
    L = np.zeros(A.shape)
    for i in range(len(evals)):
        L[i][i] = evals[i]

    # Compute A**n
    Ln = la.matrix_power(L, n)
    An = Q @ Ln @ Q.T
    return An

# Part D
def abs_det(A):
    """
    Computes the absolute value of the determinant of the matrix A
    using the LU decomposition of A.

    Argument A is assumed to be a square matrix.
    """
    # Perform the LU decomposition of A and save the permutation matrix P,
    # lower-triangular matrix L, and upper-triangular matrix U.
    P, L, U = sla.lu(A)

    # Note: det(P) = 1 or -1.

    # Note: det(L) = 1 * ... * 1 = 1, since all the diagonal entries of a
    # lower-triangular matrix such as L are 1.

    # Since det(A) = det(P) * det(L) * det(U), we have
    # det(A) = det(U) or -det(U), so |det(A)| = |det(U)|. It therefore suffices
    # to compute det(U).

    # Initializes det(U) as the multiplicative identity.
    detU = 1
    # Computes det(U) as the product of the diagonal entries of U.
    for i in range(U.shape[0]):
        detU *= U[i][i]

    # Computes |det(A)| based on the discussion above.
    abs_detA = abs(detU)
    return abs_detA

# Problem 2

# Part A
class my_complex(object):
    """
    A class for complex numbers having the form a + bi
    """

    def __init__(self, a, b):
        """
        Initializes a complex number with real part a and imaginary part b
        """
        self.a = a # store a as a parameter
        self.b = b # store b as a parameter
        
    def __str__(self):
        """
        Returns my_complex object in the form (a + bi)
        """
        return f"({self.a} + {self.b}i)"
    
    def __repr__(self):
        """
        Returns the representation of a my_complex object in the form 
        Complex(a, b).
        """
        return f"Complex({self.a}, {self.b})"
    
    def __add__(self, other):
        """
        Returns the sum of self and another complex number using the usual
        rules for complex addition.
        """
        return my_complex(self.a + other.a, self.b + other.b)
    
    def __mul__(self, other):
        """
        Returns the product of self and another complex number using the
        usual rules for complex multiplication.
        """
        return my_complex(self.a * other.a - self.b * other.b, self.a * other.b + self.b * other.a)
    
    def __sub__(self, other):
        """
        Returns the difference of self and another complex number using
        the usual rules for complex subtraction.
        """
        return self + my_complex(-1, 0) * other
    
    def real(self):
        """
        Returns the real part of a my_complex object (i.e., a).
        """
        return self.a
    
    def imag(self):
        """
        Returns the imaginary part of a my_complex object (i.e., b).
        """
        return self.b
    
    def conj(self):
        """
        Returns the complex conjugate of a my_complex object.
        That is, for a my_complex object (a + bi), returns the
        complex conjugate (a - bi).
        """
        return my_complex(self.a, -1 * self.b)
    
# Part B
def complex_high_dim(n, cls):
    """
    Generates a random element z^n of C^n, where each coordinate of z^n has
    a real part between [-100, 100] and an imaginary part between [-100, 100].

    Argument n is the dimension of C^n
    Argument cls must be either "my_complex" or "cdouble" and determines
    the class of complex number to be used in computations.
    """
    if cls == "my_complex":
        vec = np.zeros(n, dtype = my_complex)
        for i in range(n):
            vec[i] = my_complex(np.random.randint(-100, 101), np.random.randint(-100, 101))
        return vec
    elif cls == "cdouble":
        vec = np.zeros(n, dtype = np.complex128)
        for i in range(n):
            vec[i] = np.cdouble(complex(np.random.randint(-100, 101), np.random.randint(-100, 101)))
        return vec
    
def dot_product(x, y, cls):
    """
    Returns the dot product of two vectors x and y in C^n, each with entries
    in the my_complex or cdouble classes. x dot y computed using the complex
    conjugate of y.

    Arguments x and y are vectors in C^n.
    Argument cls must be either "my_complex" or "cdouble" and states whether
    the class of x and y is my_complex or cdouble.
    """
    if cls == "my_complex":
        x_dot_y = my_complex(0, 0)
        for i in range(len(x)):
            x_dot_y += (x[i] * y[i].conj())
        return x_dot_y
    elif cls == "cdouble":
        y_conj = y.conj()
        return np.dot(x, y_conj)

def norm(x, cls):
    """
    Returns the norm of a vector x with entries in the my_complex or cdouble
    classes.

    Argument x is a vector in C^n.
    Argument cls must be either "my_complex" or "cdouble" and states whether
    the class of x is my_complex or cdouble.
    """
    x_dot_x = dot_product(x, x, cls)
    if cls == "my_complex":
        return np.sqrt(x_dot_x.a)
    elif cls == "cdouble":
        return np.sqrt(x_dot_x.real)